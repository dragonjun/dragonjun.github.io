{"meta":{"title":"Programming Training","subtitle":"Programming Training","description":null,"author":"Yongjun Cho","url":"http://dragonjun.github.io"},"pages":[],"posts":[{"title":"Typescript Type Inference","slug":"/TypeScript/2016-12-08-typescript-type-inference.html","date":"2016-12-07T20:00:00.000Z","updated":"2016-12-05T14:15:01.052Z","comments":true,"path":"/TypeScript/2016-12-08-typescript-type-inference.html","link":"","permalink":"http://dragonjun.github.io//TypeScript/2016-12-08-typescript-type-inference.html","excerpt":"","text":"Basic분명하게 type annotation을 기술하지 않으면 type 추론(inference)이 사용됩니다. 1x = 3; x 변수의 type은 number로 추론됩니다. 이러한 종류의 추론은 변수와 멤버를 초기화하고, parameter 기본값을 설정하고, 함수 return type을 결정할 때 발생합니다. Contextual Typetype 추론는 TypeScript의 “다른 방향”에서도 작동합니다. 이를 “문맥적 타이핑(contextual typing)”이라고합니다. contextual typing은 표현식 type이 위치에 의해 암시 될 때 발생합니다. 123window.onmousedown = function(mouseEvent) &#123; console.log(mouseEvent.buton); // 에러&#125;; Window.onmousedown 함수 type으로 할당문의 오른쪽에있는 함수의 type과 mouseEvent parameter의 type을 추론할 수 있습니다. 명확하게 type을 기술하면 contextual type은 무시됩니다. 123window.onmousedown = function(mouseEvent: any) &#123; console.log(mouseEvent.buton);&#125;; contextual typing은 대부분의 경우에 적용됩니다. 일반적으로 함수 호출에 대한 argument, assignment의 오른쪽, type assertion, object와 array literal의 멤버, return 문에 적용됩니다.","categories":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://dragonjun.github.io/categories/TypeScript/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://dragonjun.github.io/tags/TypeScript/"}]},{"title":"Typescript Enum","slug":"/TypeScript/2016-12-07-typescript-enum.html","date":"2016-12-06T20:00:00.000Z","updated":"2016-12-04T04:33:21.859Z","comments":true,"path":"/TypeScript/2016-12-07-typescript-enum.html","link":"","permalink":"http://dragonjun.github.io//TypeScript/2016-12-07-typescript-enum.html","excerpt":"","text":"enum을 사용하면 명명된 상수 집합을 정의할 수 있습니다. 123456enum Direction &#123; Up = 1, Down, Left, Right&#125; enum의 바디는 0개 이상의 enum 멤버로 구성됩니다. enum 멤버는 관련 숫자 값을 가지며 상수이거나 계산 될 수 있습니다. enum 멤버는 다음과 같은 경우 상수로 간주됩니다. 초기 설정 값이 없고 앞의 enum 멤버가 상수입니다. 이 경우 현재 enum 멤버의 값은 이전 enum 멤버의 값에 1을 더한 값이됩니다. 이 규칙의 한 가지 예외는 열거 형의 첫 번째 멤버입니다. 초기 설정값이 없으면 값 0이 지정됩니다. enum 멤버는 상수 enum 식으로 초기화됩니다. 상수 enum 식은 컴파일 타임에 완전히 평가할 수있는 TypeScript 식의 하위 집합입니다. 표현식은 다음 중 하나 인 경우 상수 enum 식입니다. 숫자 리터럴 이전에 정의된 상수 enum 형 멤버 (다른 enum 형에서 정의 할 수 있음)에 대한 참조. member가 동일한 enum 형에 정의 된 경우 enum 명칭이 없는 이름을 사용하여 참조 할 수 있습니다. 괄호로 묶인 상수 enum 표현식 단항 연산자 +, -, ~ 가 적용된 상수 enum 표현식 상수 enum식이 피연산자로 사용되는 이진 연산자 constant enum식. 상수 enum 식이 NaN 또는 Infinity로 평가되면 컴파일 타임 오류가 발생합니다. 다른 모든 경우에 enum 멤버는 계산 된 것으로 간주됩니다. 123456789enum FileAccess &#123; // constant members None, Read = 1 &lt;&lt; 1, Write = 1 &lt;&lt; 2, ReadWrite = Read | Write, // computed member G = \"123\".length&#125; enum은 런타임에 존재하는 실제 객체입니다. 한 가지 근거는 enum 값에서 enum 이름으로 역 매핑을 유지하는 기능입니다. 12345enum Enum &#123; A&#125;let a = Enum.A;let nameOfA = Enum[Enum.A]; // \"A\" 은 123456var Enum;(function (Enum) &#123; Enum[Enum[\"A\"] = 0] = \"A\";&#125;)(Enum || (Enum = &#123;&#125;));var a = Enum.A;var nameOfA = Enum[Enum.A]; // \"A\" 으로 컴파일 됩니다. 생성 된 코드에서 enum은 forward (name -&gt; value) 매핑과 reverse (value -&gt; name) 매핑을 모두 저장하는 객체로 컴파일됩니다. enum 멤버에 대한 참조는 항상 속성 액세스로 내보내지며 결코 인라인되지 않습니다. 많은 경우에 이것은 완벽하게 유효한 해결책입니다. 그러나 때로는 요구 사항이 더 엄격합니다. enum 값에 액세스 할 때 여분의 생성 된 코드 및 추가 indirection의 비용을 지불하지 않으려면 const 열거 형을 사용할 수 있습니다. const 열거 형은 enum 키워드 앞에 오는 const 한정자를 사용하여 정의됩니다. 1234const enum Enum &#123; A = 1, B = A * 2&#125; const enum은 상수 enum 표현식만 사용할 수 있으며 일반 enum과 달리 컴파일하는 동안 완전히 제거됩니다. const enum 멤버는 인라인됩니다. 이것은 const enum가 계산 된 멤버를 가질 수 없기 때문에 가능합니다. 12345678const enum Directions &#123; Up, Down, Left, Right&#125;let directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right] 는 1var directions = [0 /* Up */, 1 /* Down */, 2 /* Left */, 3 /* Right */]; 로 컴파일 됩니다.","categories":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://dragonjun.github.io/categories/TypeScript/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://dragonjun.github.io/tags/TypeScript/"}]},{"title":"Typescript Generic","slug":"/TypeScript/2016-12-06-typescript-generic.html","date":"2016-12-05T20:00:00.000Z","updated":"2016-12-04T04:00:21.000Z","comments":true,"path":"/TypeScript/2016-12-06-typescript-generic.html","link":"","permalink":"http://dragonjun.github.io//TypeScript/2016-12-06-typescript-generic.html","excerpt":"","text":"소프트웨어 엔지니어링의 주요 부분은 잘 정의되고 일관된 API를 보유 할뿐만 아니라 재사용 할 수있는 컴포넌트를 구축하는 것입니다. 오늘의 데이터와 내일의 데이터까지 처리 할 수 있는 컴포넌트는 대형 소프트웨어 시스템 구축을 위한 가장 유연한 기능을 제공합니다. C # 및 Java와 같은 언어에서 재사용 가능한 구성 요소를 작성하기위한 도구 상자의 주요 도구 중 하나는 제네릭 즉 단일 type이 아닌 다양한 type에서 작동 할 수있는 구성 요소를 생성하는 것입니다. 이를 통해 사용자는 이러한 구성 요소를 사용하고 자신의 유형을 사용할 수 있습니다. Hello World of Genericgeneric에서 “Hello world”에 해당되는 identity function으로 시작해 봅시다. indentity function은 전달받은 것으로 반환하는 함수 입니다. generic가 없다면 identity 함수에 특정 type을 부여해야합니다. 123function identity(arg: number): number &#123; return arg;&#125; 또는 any type을 사용하여 ID 함수를 기술 할 수 있습니다. 123function identity(arg: any): any &#123; return arg;&#125; any를 사용하는 것은 확실히 arg의 타입에 대한 모든 타입을 받아 들일 것이지만, 실제로 함수가 리턴 할 때 그 type이 무엇인지에 대한 정보를 잃어 버리게됩니다. number를 전달하면, 우리가 가지고있는 유일한 정보는 any 타입이 리턴 될 수 있다는 것입니다. 대신, 우리는 반환되는 것을 나타내는 데 사용할 수있는 방식으로 argument type을 캡처하는 방법이 필요합니다. 여기서 type variable는 value가 아닌 type에서 작동하는 특별한 종류의 변수입니다. 123function identity&lt;T&gt;(arg: T): T &#123; return arg;&#125; 이제 identity 함수에 tye variable T를 추가했습니다. 이 T는 type (예 : number)을 캡처하여 나중에 해당 정보를 사용할 수 있도록합니다. 여기에서 T를 리턴 type으로 다시 사용합니다. 다양한 type에서 작동하므로 identity 함수가 generic하다고 말흡니다. any를 사용하는 것과는 달리, argument와 return type에 number를 사용하는 첫 번째 identity 함수만큼 정확합니다(즉, 정보를 잃지 않습니다). generic indentity 함수를 작성한 후에는 두 가지 방법 중 하나로 호출 할 수 있습니다. 첫 번째 방법은 type argument를 포함한 모든 argument를 함수에 전달하는 것입니다. 1let output = identity&lt;string&gt;(\"myString\"); &lt;&gt;를 사용하여 string를 T에 argument로 명시적으로 설정합니다. 두 번째 방법은 가장 일반적인 방법이기도 합니다. 여기서 우리는 type argument inference을 사용합니다. 컴파일러가 우리가 전달하는 argument의 type에 따라 자동으로 T 값을 설정합니다. 1let output = identity(\"myString\"); 꺽쇠 괄호 (&lt;&gt;) 안에 명시 적으로 type을 전달할 필요가 없었습니다. 컴파일러는 방금 &quot;myString&quot;값을보고 T를 해당 유형으로 설정합니다. type argument inference은 코드를 더 짧고 가독성있게 유지하는 유용한 도구가 될 수 있지만, 보다 복잡한 예제에서 컴파일러가 타입을 추론하지 못하면 앞의 예제에서 했던 것처럼 타입 인자를 명시 적으로 전달해야 할 수도 있습니다 . Working with Generic Type Variable함수 본문 안에서 type parameter를 올바르게 사용해야 합니다. 즉, type parameter를 모든 type이 될 수있는 것처럼 취급해야 합니다. 123function identity&lt;T&gt;(arg: T): T &#123; return arg;&#125; arg의 length를 콘솔에 기록하려면 어떻게 해야 할까요? 1234function loggingIdentity&lt;T&gt;(arg: T): T &#123; console.log(arg.length); return arg;&#125; arg에 .length 멤버가 존재하는지 알 수 없기 때문에 에러가 발생합니다. type variable은 모든 type에 사용되므로 .length 멤버가 없는 `number’를 전달할 수 있습니다. 우리가 실제로이 함수가 T가 아닌 T의 배열을 작업한다고 가정 해 보겠습니다. 우리가 배열을 다루기 때문에, .length 멤버를 사용할 수 있어야 합니다. 1234function loggingIdentity&lt;T&gt;(arg: T[]): T[] &#123; console.log(arg.length); return arg;&#125; loggingIdentity는 “generic function loggingIdentity가 type parameter T와 T의 배열을 argument arg로 받고 T의 배열을 반환하는” type입니다. number 배열을 전달하면 T가 number에 바인드하므로 number 배열을 되돌려 받습니다. 이렇게 하면 전체 type보다는 우리가 작업하는 type의 일부로 generic type variable T를 사용할 수 있으므로 유연성이 향상됩니다. 다음과 같이 작성할 수도 있습니다. 1234function loggingIdentity&lt;T&gt;(arg: Array&lt;T&gt;): Array&lt;T&gt; &#123; console.log(arg.length); // Array has a .length, so no more error return arg;&#125; Generic Type함수 type과 generic 인터페이스를 만드는 방법에 대해 살펴 보겠습니다. generic 함수의 문법은 type parameter를 &lt;&gt; 기술합니다. 12345function identity&lt;T&gt;(arg: T): T &#123; return arg;&#125;let myIdentity: &lt;T&gt;(arg: T) =&gt; T = identity; generic type을 object literal type의 call signature로 기술할 수도 있습니다. 12345function identity&lt;T&gt;(arg: T): T &#123; return arg;&#125;let myIdentity: &#123;&lt;T&gt;(arg: T): T&#125; = identity; 예제에서 object literal을 가져 와서 인터페이스로 옮깁니다. 123456789interface GenericIdentityFn &#123; &lt;T&gt;(arg: T): T;&#125;function identity&lt;T&gt;(arg: T): T &#123; return arg;&#125;let myIdentity: GenericIdentityFn = identity; 비슷한 예를 들어, generic parameter를 전체 인터페이스의 parameter로 옮길 수도 있습니다. 이렇게하면 어떤 type이 generic이 되어 있는지 확인할 수 있습니다 (예 : Dictionary이 아닌 Dictionary&lt;string&gt;). 이렇게하면 인터페이스의 다른 모든 구성원이 type parameter를 볼 수 있습니다. 123456789interface GenericIdentityFn&lt;T&gt; &#123; (arg: T): T;&#125;function identity&lt;T&gt;(arg: T): T &#123; return arg;&#125;let myIdentity: GenericIdentityFn&lt;number&gt; = identity; tye parameter를 call signature에 직접 적용 할때와 인터페이스 자체에 넣을 때를 이해하면 type의 어떤 측면이 generic인지 설명하는 데 도움이됩니다. generic 인터페이스 외에도 generic 클래스를 만들 수도 있습니다. generic enum 및 generic namespace를 만들 수는 없습니다. Generic Classgeneric 클래스에는 클래스 이름 뒤에 꺾쇠 괄호 (&lt;&gt;)로 묶인 geenric type parameter 목록이 있습니다. 1234567891011121314class GenericNumber&lt;T&gt; &#123; zeroValue: T; add: (x: T, y: T) =&gt; T;&#125;let myGenericNumber = new GenericNumber&lt;number&gt;();myGenericNumber.zeroValue = 0;myGenericNumber.add = function(x, y) &#123; return x + y; &#125;;let stringNumeric = new GenericNumber&lt;string&gt;();stringNumeric.zeroValue = \"\";stringNumeric.add = function(x, y) &#123; return x + y; &#125;;console.log(stringNumeric.add(stringNumeric.zeroValue, \"test\")); 클래스에 대한 섹션에서 살펴본 것처럼 클래스에는 정적 측면과 인스턴스 측면의 두 가지 유형이 있습니다. generic 클래스는 정적 측면보다는 인스턴스 측면에서만 generic이므로 클래스를 사용하여 작업 할 때 정적 멤버는 클래스의 type parameter를 사용할 수 없습니다. Generic Constraint1234function loggingIdentity&lt;T&gt;(arg: T): T &#123; console.log(arg.length); // 에러 return arg;&#125; 임의의 모든 type으로 작업하는 대신이 함수가 .length 속성도 가진 type에서 작동하도록 제한하고 싶습니다. 그렇게하기 위해서 우리는 T가 할 수있는 것에 대한 제약으로서 우리의 요구 사항을 나열해야합니다. 이렇게하기 위해 우리는 제약 조건을 설명하는 인터페이스를 만들 것입니다. 여기서는 하나의 .length 속성을 가진 인터페이스를 만든 다음 이 인터페이스와 extends 키워드를 사용하여 제약 조건을 나타냅니다. 12345678interface Lengthwise &#123; length: number;&#125;function loggingIdentity&lt;T extends Lengthwise&gt;(arg: T): T &#123; console.log(arg.length); return arg;&#125; 제네릭 함수가 이제 제한되어 있기 때문에 더 이상 모든 type에서 작동하지 않습니다. 1loggingIdentity(3); // 에러 대신 모든 필수 속성이있는 type의 값을 전달해야합니다. 1loggingIdentity(&#123;length: 10, value: 3&#125;); generic constraint에서 type parameter 사용다른 type parameter에 의해 제한되는 type parameter를 선언 할 수 있습니다. 예를 들어 여기서는 두 개의 객체를 가져 와서 하나에서 다른 객체로 속성을 복사하려고합니다. 실수로 source의 추가 속성을 작성하지 않도록하려면 두 가지 type간에 제약 조건을 적용합니다. 1234567891011function copyFields&lt;T, U extends T&gt;(source: T, target: U): U &#123; for (let id in source) &#123; target[id] = source[id]; &#125; return target;&#125;let x = &#123; a: 1, b: 2, c: 3, d: 4 &#125;;copyFields(&#123; b: 10, d: 20 &#125;, x);copyFields(&#123; Q: 90 &#125;, x); // 에러 generic에서 class type 사용generics를 사용하여 팩토리를 생성 할 때 constructor 함수를 사용하여 클래스 유형을 참조해야합니다. 예를 들어, 123function create&lt;T&gt;(c: &#123;new(): T; &#125;): T &#123; return new c();&#125; 고급 예제는 prototype 속성을 사용하여 constructor 함수와 class type의 인스턴스 측면 사이의 관계를 추론하고 제한합니다. 123456789101112131415161718192021222324252627class BeeKeeper &#123; hasMask: boolean;&#125;class ZooKeeper &#123; nametag: string;&#125;class Animal &#123; numLegs: number;&#125;class Bee extends Animal &#123; keeper: BeeKeeper;&#125;class Lion extends Animal &#123; keeper: ZooKeeper;&#125;function findKeeper&lt;A extends Animal, K&gt; (a: &#123;new(): A; prototype: &#123;keeper: K&#125;&#125;): K &#123; return a.prototype.keeper;&#125;findKeeper(Lion).nametag; // typechecks!","categories":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://dragonjun.github.io/categories/TypeScript/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://dragonjun.github.io/tags/TypeScript/"}]},{"title":"Typescript Function","slug":"/TypeScript/2016-12-05-typescript-function.html","date":"2016-12-04T20:00:00.000Z","updated":"2016-12-03T14:13:42.928Z","comments":true,"path":"/TypeScript/2016-12-05-typescript-function.html","link":"","permalink":"http://dragonjun.github.io//TypeScript/2016-12-05-typescript-function.html","excerpt":"","text":"함수는 JavaScript의 모든 응용 프로그램을 구성하는 기본 요소입니다. 추상화 계층, 클래스 모방, 정보 숨김 및 모듈을 함수로 구성합니다. TypeScript에서는 클래스, 네임 스페이스 및 모듈이 있지만 함수는 여전히 작업 수행 방법을 설명하는 데 중요한 역할을합니다. TypeScript는 표준 JavaScript 함수에 몇 가지 새로운 기능을 추가하여보다 쉽게 작업 할 수 있도록합니다. FunctionJavaScript에서와 마찬가지로, TypeScript 함수는 명명된 함수 또는 익명 함수로 만들 수 있습니다. 이를 통해 API에서 함수 목록을 작성하든 한번 사용하는 함수를 다른 함수로 이전 할 것인지에 관계없이 응용 프로그램에 가장 적합한 방법을 선택할 수 있습니다. 자바 스크립트에서 이러한 두 가지 접근 방식을 빠르게 요약하면 다음과 같습니다. 1234567// Named functionfunction add(x, y) &#123; return x + y;&#125;// Anonymous functionlet myAdd = function(x, y) &#123; return x+y; &#125;; JavaScript와 마찬가지로 함수는 외부의 변수를 참조 할 수 있습니다. 이러한 참조를 변수를 capture한다고 말합니다. 1234let z = 100;function addToZ(x, y) &#123; return x + y + z;&#125; Function TypeTyping the function12345function add(x: number, y: number): number &#123; return x + y;&#125;let myAdd = function(x: number, y: number): number &#123; return x+y; &#125;; 각 parameter에 type을 추가하고 return type을 추가해서 함수 자체에도 type을 추가할 수 있습니다. TypeScript는 return 문을보고 return type을 파악할 수 있으므로 많은 경우에 생략할 수 있습니다. Writing the function type함수를 입력 했으므로 각 함수 유형을 살펴보고 함수의 전체 유형을 작성해 보겠습니다. 12let myAdd: (x:number, x:number) =&gt; number;myAdd = function(x: number, y: number): number &#123; return x + y; &#125;; 함수의 type은 parameter type과 return type 두 부분으로 구성됩니다. 둘 사이는 굵은 화살표 (=&gt;)로 구분합니다. type 추론할당문에서 한쪽에만 type을 명시하더라도 TypeScript 컴파일러는 다른쪽의 type을 알 수가 있습니다. 1234let myAdd = function(x: number, y: number): number &#123; return x + y; &#125;;let myAdd: (baseValue:number, increment:number) =&gt; number = function(x, y) &#123; return x + y; &#125;; 이런 type 추론을 “contextual typing”라고 합니다. Optional and Default ParameterTypeScript에서는 함수를 호출할때는 모든 파라미터를 전달해야 합니다. 이것은 null이나 undefined가 주어질 수 없다는 것을 의미하는 것이 아니라, 함수가 호출 될 때 컴파일러는 사용자가 각 매개 변수에 값을 제공했는지 확인합니다. 컴파일러는 또한 이 매개 변수가 함수로 전달되는 유일한 매개 변수라고 가정합니다. 즉, 함수에 주어진 아규먼트의 수는 함수가 예상하는 파라미터의 수와 일치해야합니다. 1234567function buildName(firstName: string, lastName: string) &#123; return firstName + \" \" + lastName;&#125;let result1 = buildName(\"Bob\"); // 에러let result2 = buildName(\"Bob\", \"Adams\", \"Sr.\"); // 에러let result3 = buildName(\"Bob\", \"Adams\"); 자바 스크립트에서 모든 매개 변수는 선택 사항이며 사용자는 적합하다고 판단되는 매개 변수를 제외할 수 있습니다. 제외된 파라미터는 undefined가 됩니다. TypeScript에서는 파라미터의 끝에 ?를 붙여서 선택적 파라미터라고 기술할 수 있습니다. 12345678910function buildName(firstName: string, lastName?: string) &#123; if (lastName) return firstName + \" \" + lastName; else return firstName;&#125;let result1 = buildName(\"Bob\");let result2 = buildName(\"Bob\", \"Adams\", \"Sr.\"); // 에러let result3 = buildName(\"Bob\", \"Adams\"); 모든 선택적 파라미터는 필수 파라미터 다음에 기술해야 합니다. TypeScript에서 아큐먼트를 전달하지 않거나 undefined를 전달할때 파라미터에 할당되는 값을 설정할 수 있습니다. 이를 default 파라미터라고합니다. 12345678function buildName(firstName: string, lastName = \"Smith\") &#123; return firstName + \" \" + lastName;&#125;let result1 = buildName(\"Bob\"); // \"Bob Smith\"let result2 = buildName(\"Bob\", undefined); // \"Bob Smith\"let result3 = buildName(\"Bob\", \"Adams\", \"Sr.\");let result4 = buildName(\"Bob\", \"Adams\"); optional 파라미터와 default 파라미터는 동일한 type이 됩니다. 다음 두 예는 (firstName : string, lastName ?: string) =&gt; string로 같은 type입니다. 123function buildName(firstName: string, lastName?: string) &#123; // ...&#125; 123function buildName(firstName: string, lastName = \"Smith\") &#123; // ...&#125; optional 파라미터와 달리 default 파라미터는 필수 파라미터 앞에 올 수도 있습니다. 12345678function buildName(firstName = \"Will\", lastName: string) &#123; return firstName + \" \" + lastName;&#125;let result1 = buildName(\"Bob\"); // 에러let result2 = buildName(\"Bob\", \"Adams\", \"Sr.\"); // 에러let result3 = buildName(\"Bob\", \"Adams\"); // returns \"Bob Adams\"let result4 = buildName(undefined, \"Adams\"); // returns \"Will Adams\" Rest Parameter파라미터의 갯수가 일정하게 정해지 있지 않을 때 JavaScript에서는 arguments를 사용하며 TypeScript에서는 ...를 사용합니다. 123456function buildName(firstName: string, ...restOfName: string[]) &#123; return firstName + \" \" + restOfName.join(\" \");&#125;let buildNameFun: (fname: string, ...rest: string[]) =&gt; string = buildName;let employeeName = buildNameFun(\"Joseph\", \"Samuel\", \"Lucas\", \"MacKinzie\");console.log(employeeName); thisJavaScript에서 this를 사용하는 방법을 배우는 것은 통과 의식과도 같은 것 입니다. TypeScript는 JavaScript의 superset이므로 TypeScript 개발자도 또한 this 사용하는 방법을 배워야 하고 올바르게 사용되지 않는 시점을 찾는 방법을 배워야합니다. 다행스럽게도 TypeScript를 사용하면 두 가지 기술을 사용하여 this의 잘못된 용도를 잡을 수 있습니다. JavaScript에서 this가 어떻게 작동하는지 알아야 할 필요가 있다면 Yehuda Katz의 Understanding JavaScript Function Invocation과 “this”를 먼저 읽으십시오. 여기서는 기본 사항 만 다루겠습니다. this and arrow function자바 스크립트에서 이것은 함수가 호출 될 때 설정된 변수입니다. 이것은 매우 강력하고 유연한 기능이지만 항상 함수가 실행되는 상황에 대해 알 필요가 있습니다. 이것은 특히 함수를 반환하거나 인수를 함수로 전달할 때 혼란 스럽습니다. 1234567891011121314151617let deck = &#123; suits: [\"hearts\", \"spades\", \"clubs\", \"diamonds\"], cards: Array(52), createCardPicker: function() &#123; return function() &#123; let pickedCard = Math.floor(Math.random() * 52); let pickedSuit = Math.floor(pickedCard / 13); return &#123;suit: this.suits[pickedSuit], card: pickedCard % 13&#125;; &#125; &#125;&#125;let cardPicker = deck.createCardPicker();let pickedCard = cardPicker();console.log(\"card: \" + pickedCard.card + \" of \" + pickedCard.suit); createCardPicker는 그 자체로 함수를 반환하는 함수입니다. 예제를 실행하면 오류가 발생합니다. 이것은 createCardPicker에 의해 생성 된 함수인 cardPicker()에서 사용되는 this가 deck 객체 대신 window로 설정되기 때문입니다. (참고 : strict mode에서는 this는 window가 아니고 undefined가 됩니다.) 이 문제를 해결하기 위해서는 ECMAScript 6 arrow syntax를 사용해서 함수식을 변경합니다. arrow function은 함수가 호출되는 곳이 아닌 하뭇가 생성되는 곳에서 this를 capture합니다. 1234567891011121314151617let deck = &#123; suits: [\"hearts\", \"spades\", \"clubs\", \"diamonds\"], cards: Array(52), createCardPicker: function() &#123; return () =&gt; &#123; let pickedCard = Math.floor(Math.random() * 52); let pickedSuit = Math.floor(pickedCard / 13); return &#123;suit: this.suits[pickedSuit], card: pickedCard % 13&#125;; &#125; &#125;&#125;let cardPicker = deck.createCardPicker();let pickedCard = cardPicker();console.log(\"card: \" + pickedCard.card + \" of \" + pickedCard.suit); this 파라미터this.suits [pickedSuit]의 type은 any입니다. this가 객체 리터럴 내부의 함수 표현식에서 비롯 되었기 때문입니다.Card와 Deck 인터페이스를 추가하면 type을 명확하고 쉽게 재사용 할 수 있습니다. 123456789101112131415161718192021222324252627interface Card &#123; suit: string; card: number;&#125;interface Deck &#123; suits: string[]; cards: number[]; createCardPicker(this: Deck): () =&gt; Card;&#125;let deck: Deck = &#123; suits: [\"hearts\", \"spades\", \"clubs\", \"diamonds\"], cards: Array(52), // NOTE: The function now explicitly specifies that its callee must be of type Deck createCardPicker: function(this: Deck) &#123; return () =&gt; &#123; let pickedCard = Math.floor(Math.random() * 52); let pickedSuit = Math.floor(pickedCard / 13); return &#123;suit: this.suits[pickedSuit], card: pickedCard % 13&#125;; &#125; &#125;&#125;let cardPicker = deck.createCardPicker();let pickedCard = cardPicker();console.log(\"card: \" + pickedCard.card + \" of \" + pickedCard.suit); this parameter in callback나중에 콜백 할 라이브러리에 함수를 전달할 때 콜백에서이 오류를 실행할 수도 있습니다. 콜백을 호출하는 라이브러리는 일반 함수처럼 호출하기 때문에 이것은 정의되지 않습니다. 일부 작업에서는이 매개 변수를 사용하여 콜백으로 인한 오류를 방지 할 수 있습니다. 먼저, 라이브러리 제작자는 다음과 같이 콜백 유형에 주석을 달아야합니다. 123interface UIElement &#123; addClickListener(onclick: (this: void, e: Event) =&gt; void): void;&#125; this: void는 addClickListener 함수의 파라미터 onclick은 this type을 필요로 하지 않는 함수라는 것을 기술합니다. 둘째, this를 파라미터에 명시합니다. 12345678910class Handler &#123; info: string; onClickBad(this: Handler, e: Event) &#123; // oops, used this here. using this callback would crash at runtime this.info = e.message; &#125;;&#125;let uiElement: UIElement;let h = new Handler();uiElement.addClickListener(h.onClickBad); // 에러 this를 파라미터에 추가 하면 onClickBad는 Handler의 인스턴스에서 호출되어야 한다는 사실을 명시합니다. 그런 다음 TypeScript는 addClickListener에 this: void 파라미터가 있는 함수가 필요하다는 것을 감지합니다. 오류를 수정하려면 this의 type을 변경합니다. 123456789class Handler &#123; info: string; onClickGood(this: void, e: Event) &#123; console.log('clicked!'); &#125;&#125;let uiElement: UIElement;let h = new Handler();uiElement.addClickListener(h.onClickGood); onClickGood 함수에서 this를 void로 지정했기 때문에 addClickListener에 전달할 수 있습니다. 물론 이것은 this.info를 사용할 수 없다는 것을 의미합니다. 둘 다 원한다면 arrow function을 사용해야합니다. 1234class Handler &#123; info: string; onClickGood = (e: Event) =&gt; &#123; this.info = e.message &#125;&#125; 이것은 arrow function가 this를 capture하지 않기 때문입니다. 그래서 여러분은 항상 this: void를 기대하는 무언가에 전달할 수 있습니다. 단점은 Handler type의 객체 당 하나의 arrow function가 생성된다는 것입니다. 한편, 메소드는 한 번만 생성되어 Handler의 prototype에 결합됩니다. 메소드는 Handler type의 모든 객체간에 공유됩니다. OverloadJavaScript는 본질적으로 매우 동적인 언어입니다. 단일 JavaScript 함수가 전달된 argument의 형태를 기반으로 여러 type의 객체를 반환하는 경우는 흔합니다. 12345678910111213141516171819202122let suits = [\"hearts\", \"spades\", \"clubs\", \"diamonds\"];function pickCard(x): any &#123; // Check to see if we're working with an object/array // if so, they gave us the deck and we'll pick the card if (typeof x == \"object\") &#123; let pickedCard = Math.floor(Math.random() * x.length); return pickedCard; &#125; // Otherwise just let them pick the card else if (typeof x == \"number\") &#123; let pickedSuit = Math.floor(x / 13); return &#123; suit: suits[pickedSuit], card: x % 13 &#125;; &#125;&#125;let myDeck = [&#123; suit: \"diamonds\", card: 2 &#125;, &#123; suit: \"spades\", card: 10 &#125;, &#123; suit: \"hearts\", card: 4 &#125;];let pickedCard1 = myDeck[pickCard(myDeck)];console.log(\"card: \" + pickedCard1.card + \" of \" + pickedCard1.suit);let pickedCard2 = pickCard(15);console.log(\"card: \" + pickedCard2.card + \" of \" + pickedCard2.suit); 여기서 pickCard 함수는 argument에 따라서 두 가지 다른 것을 반환합니다. deck를 나타내는 객체를 전달하면 함수가 카드를 선택합니다. 사용자가 카드를 선택하면 우리는 그들이 선택한 카드를 알려줍니다. type 시스템으로 어떻게 기술 할 수 있습니까요? 그 대답은 과부하 목록과 동일한 함수에 대해 여러 함수 유형을 제공하는 것입니다. 이 목록은 컴파일러가 함수 호출을 해결하는 데 사용할 것입니다. pickCard가 받아 들일 수있는 부분과 반환하는 부분을 설명하는 오버로드 목록을 만듭니다. 123456789101112131415161718192021222324let suits = [\"hearts\", \"spades\", \"clubs\", \"diamonds\"];function pickCard(x: &#123;suit: string; card: number; &#125;[]): number;function pickCard(x: number): &#123;suit: string; card: number; &#125;;function pickCard(x): any &#123; // Check to see if we're working with an object/array // if so, they gave us the deck and we'll pick the card if (typeof x == \"object\") &#123; let pickedCard = Math.floor(Math.random() * x.length); return pickedCard; &#125; // Otherwise just let them pick the card else if (typeof x == \"number\") &#123; let pickedSuit = Math.floor(x / 13); return &#123; suit: suits[pickedSuit], card: x % 13 &#125;; &#125;&#125;let myDeck = [&#123; suit: \"diamonds\", card: 2 &#125;, &#123; suit: \"spades\", card: 10 &#125;, &#123; suit: \"hearts\", card: 4 &#125;];let pickedCard1 = myDeck[pickCard(myDeck)];alert(\"card: \" + pickedCard1.card + \" of \" + pickedCard1.suit);let pickedCard2 = pickCard(15);alert(\"card: \" + pickedCard2.card + \" of \" + pickedCard2.suit); 이 변경으로 오버로드가 이제 pickCard 함수에 대한 유형 확인 된 호출을 제공합니다. 컴파일러가 올바른 typecheck를 선택하도록하기 위해 기본 JavaScript와 비슷한 과정을 거칩니다. 오버로드 목록을 보고 제공된 매개 변수를 사용하여 함수를 호출하는 첫 번째 오버로드 시도를 계속합니다. 일치하는 항목을 찾으면 올바른 오버로드로써 이 오버로드를 선택합니다. 이런 이유로 가장 구체적인 것이 먼저 나열되어야 합니다. pickCard(x): any 함수는 오버로드 리스트의 일부가 아니므로 오브젝트를 취하는 오버로드와 숫자를 취하는 오버로드의 두 가지 오버로드 만 있습니다. 다른 매개 변수 유형으로 pickCard를 호출하면 오류가 발생합니다.","categories":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://dragonjun.github.io/categories/TypeScript/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://dragonjun.github.io/tags/TypeScript/"}]},{"title":"Typescript Class","slug":"/TypeScript/2016-12-04-typescript-class.html","date":"2016-12-03T20:00:00.000Z","updated":"2016-12-02T14:28:44.422Z","comments":true,"path":"/TypeScript/2016-12-04-typescript-class.html","link":"","permalink":"http://dragonjun.github.io//TypeScript/2016-12-04-typescript-class.html","excerpt":"","text":"전통적인 JavaScript는 재사용 가능한 컴포넌트를 빌드하는 기본 수단으로 함수와 프로토 타입 기반 상속에 중점을두고 있지만, 클래스가 기능을 상속하고 객체가 이러한 클래스에서 빌드되는 객체 지향 접근 방식에 익숙한 프로그래머에게는 다소 어색함을 느낄 수 있습니다. ECMAScript 2015(ECMAScript 6)에서 부터는 JavaScript 프로그래머는이 객체 지향 클래스 기반 접근 방식을 사용하여 응용 프로그램을 빌드 할 수 있습니다. TypeScript에서는 다음 JavaScript 버전을 기다릴 필요없이 개발자들이 이 기술들을 지금 사용하고 모든 주요 브라우저 및 플랫폼에서 작동하는 JavaScript로 컴파일 할 수 있습니다. Class1234567891011class Greeter &#123; greeting: string; constructor(message: string) &#123; this.greeting = message; &#125; greet() &#123; return \"Hello, \" + this.greeting; &#125;&#125;let greeter = new Greeter(\"world\"); 이전에 C #이나 Java를 사용했다면 문법이 익숙할 것입니다. 새로운 클래스인 Greeter를 선언합니다. 이 클래스에는 greeting 속성, 생성자 및 greet method의 세 가지 멤버가 있습니다. 클래스의 멤버를 참조할때 this.를 앞에 붙였습니다. 마지막 줄에서는 new를 사용하여 Greeter 클래스의 인스턴스를 생성합니다. 앞서 정의한 생성자를 호출하여 Greeter 형태의 새 객체를 만들고 생성자를 실행하여 초기화합니다. InheritanceTypeScript에서는 일반적인 객체 지향 패턴을 사용할 수 있습니다. 물론 클래스 기반 프로그래밍에서 가장 기본적인 패턴 중 하나는 상속을 사용하여 기존 클래스를 확장하여 새로운 클래스를 생성 할 수 있다는 것입니다. 1234567891011121314151617181920212223242526272829class Animal &#123; name: string; constructor(theName: string) &#123; this.name = theName; &#125; move(distanceInMeters: number = 0) &#123; console.log(`$&#123;this.name&#125; moved $&#123;distanceInMeters&#125;m.`); &#125;&#125;class Snake extends Animal &#123; constructor(name: string) &#123; super(name); &#125; move(distanceInMeters = 5) &#123; console.log(\"Slithering...\"); super.move(distanceInMeters); &#125;&#125;class Horse extends Animal &#123; constructor(name: string) &#123; super(name); &#125; move(distanceInMeters = 45) &#123; console.log(\"Galloping...\"); super.move(distanceInMeters); &#125;&#125;let sam = new Snake(\"Sammy the Python\");let tom: Animal = new Horse(\"Tommy the Palomino\");sam.move();tom.move(34); 이 예제는 TypeScript의 다른 언어에 공통적 인 상속 기능 중 상당수를 다룹니다. 여기서 하위 클래스를 만드는 데 사용되는 extends 키워드를 볼 수 있습니다. 생성자 함수를 포함하는 파생 클래스는 기본 클래스의 생성자 함수를 실행하려면 super()를 호출해야합니다. 또한이 예제는 기본 클래스의 메서드를 하위 클래스에 특화된 메서드로 재정의하는 방법을 보여줍니다. 여기에서 Snake와 Horse는 Animal로부터의 move를 오버라이드하는 move 메소드를 생성하여 각 클래스에 특정 기능을 부여합니다. tom은 Animal로 선언되었지만 그 값은 Horse이므로 tom.move(34)에서 Horse에서 재정의 메소드를 호출합니다. 1234Slithering...Sammy the Python moved 5m.Galloping...Tommy the Palomino moved 34m. Public, Private and Protected modifierpublic by defaultTypeScript에서는 class의 각 멤버는 기본적으로 public입니다. privateprivate로 지정하면 class밖에서 접근할 수 없습니다. 123456class Animal &#123; private name: string; constructor(theName: string) &#123; this.name = theName; &#125;&#125;new Animal(\"Cat\").name; // 에러 TypeScript는 structural type 시스템입니다. 두 가지 type을 비교할 때, 모든 멤버의 type이 호환 가능하다면 type 자체가 호환 가능하다고 말합니다. 그러나 private 및 protected 멤버가 있는 type을 비교할 때 이러한 유형을 다르게 처리합니다. 두개의 type이 호환 가능한 것으로 간주되려면 그 중 하나에 private 멤버가 있는 경우 다른 하나도 동일한 선언에서 시작된 private 구성원을 가져야합니다. protected 멤버도 마찬가지입니다. 1234567891011121314151617181920class Animal &#123; private name: string; constructor(theName: string) &#123; this.name = theName; &#125;&#125;class Rhino extends Animal &#123; constructor() &#123; super(\"Rhino\"); &#125;&#125;class Employee &#123; private name: string; constructor(theName: string) &#123; this.name = theName; &#125;&#125;let animal = new Animal(\"Goat\");let rhino = new Rhino();let employee = new Employee(\"Bob\");animal = rhino;animal = employee; // 에러: 'Animal'과 'Employee'는 호환되지 않습니다 이 예제에서는 Animal과 Rhino가 있고 Rhino는 Animal의 하위 클래스있습니다. 또한 형태면에서 Animal과 똑같이 보이는 새로운 클래스 Employee가 있습니다. 우리는 이러한 클래스의 인스턴스를 생성 한 다음 서로를 할당하여 어떤 일이 발생하는지 봅니다. Animal의 private name: string을 동일한 선언에서 형태의 private 측면을 공유하기 때문에 Animal과 Rhino는 호환됩니다. 그러나 Employee의 경우는 그렇지 않습니다. Employee에서 Animal로 할당하려고 할 때 이러한 type이 호환되지 않는다는 오류가 발생합니다. Employee에는 name이라는 private 멤버가 있지만, Animal에서 선언 한 멤버는 아닙니다. protectedprotected 멤버는 하위클래스에서 접근할 수 있습니다. 123456789101112131415161718192021class Person &#123; protected name: string; constructor(name: string) &#123; this.name = name; &#125;&#125;class Employee extends Person &#123; private department: string; constructor(name: string, department: string) &#123; super(name); this.department = department; &#125; public getElevatorPitch() &#123; return `Hello, my name is $&#123;this.name&#125; and I work in $&#123;this.department&#125;.`; &#125;&#125;let howard = new Employee(\"Howard\", \"Sales\");console.log(howard.getElevatorPitch());console.log(howard.name); // 에러 constructor를 protectec로 지정할 수 있습니다. 1234567891011121314151617181920class Person &#123; protected name: string; protected constructor(theName: string) &#123; this.name = theName; &#125;&#125;class Employee extends Person &#123; private department: string; constructor(name: string, department: string) &#123; super(name); this.department = department; &#125; public getElevatorPitch() &#123; return `Hello, my name is $&#123;this.name&#125; and I work in $&#123;this.department&#125;.`; &#125;&#125;let howard = new Employee(\"Howard\", \"Sales\");let john = new Person(\"John\"); // 에러: 'Person' constructor is protected Readonly modifierreadonly 키워드를 사용하여 속성을 읽기 전용으로 만들 수 있습니다. 읽기 전용 속성은 선언 또는 생성자에서 초기화해야합니다. 123456789class Octopus &#123; readonly name: string; readonly numberOfLegs: number = 8; constructor (theName: string) &#123; this.name = theName; &#125;&#125;let dad = new Octopus(\"Man with the 8 strong legs\");dad.name = \"Man with the 3-piece suit\"; // error! name is readonly. parameter property마지막 예제에서 우리는 Octopus 클래스에서 읽기 전용 멤버 name과 생성자 매개 변수 인 theName을 선언해야만했습니다. 그런 다음 name을 theName으로 즉시 설정했습니다. 이것은 매우 일반적인 방법으로 밝혀졌습니다. 매개 변수 속성을 사용하면 한 곳에서 멤버를 만들고 초기화 할 수 있습니다. 다음은 매개 변수 속성을 사용하여 이전 Octopus 클래스의 추가 개정판입니다. 12345class Octopus &#123; readonly numberOfLegs: number = 8; constructor(readonly name: string) &#123; &#125;&#125; parameter property는 accessibility modifier나 readonly를 생성자 매개 변수 앞에 접두어를 붙임으로써 선언됩니다. static property123456789101112131415class Grid &#123; static origin = &#123;x: 0, y: 0&#125;; calculateDistanceFromOrigin(point: &#123;x: number; y: number;&#125;) &#123; let xDist = (point.x - Grid.origin.x); let yDist = (point.y - Grid.origin.y); return Math.sqrt(xDist * xDist + yDist * yDist) / this.scale; &#125; constructor (public scale: number) &#123; &#125;&#125;let grid1 = new Grid(1.0); // 1x scalelet grid2 = new Grid(5.0); // 5x scaleconsole.log(grid1.calculateDistanceFromOrigin(&#123;x: 10, y: 10&#125;));console.log(grid2.calculateDistanceFromOrigin(&#123;x: 10, y: 10&#125;)); abstrac classabstract 클래스는 다른 클래스를 파생시킬 수있는 기본 클래스입니다. 직접 인스턴스화 할 수 없습니다. 인터페이스와 달리 abstract 클래스에는 멤버에 대한 구현 세부 정보가 포함될 수 있습니다. abstract 키워드는 abstract 클래스뿐만 아니라 abstract 클래스 내에서 abstract 메소드를 정의하는 데 사용됩니다. 123456abstract class Animal &#123; abstract makeSound(): void; move(): void &#123; console.log(\"roaming the earth...\"); &#125;&#125; abstract으로 표시된 abstract 클래스 내의 메소드에는 구현이 포함되어 있지 않으므로 파생 클래스에서 구현해야합니다. abstract 메소드는 인터페이스 메소드와 유사한 구문을 사용합니다. 둘 다 메소드 본문을 포함하지 않고 메소드의 서명을 정의합니다. 그러나 abstract 메소드는 abstract 키워드를 포함해야하며 선택적으로 access modifier를 포함 할 수 있습니다. 123456789101112131415161718192021222324252627abstract class Department &#123; constructor(public name: string) &#123; &#125; printName(): void &#123; console.log(\"Department name: \" + this.name); &#125; abstract printMeeting(): void; // must be implemented in derived classes&#125;class AccountingDepartment extends Department &#123; constructor() &#123; super(\"Accounting and Auditing\"); // constructors in derived classes must call super() &#125; printMeeting(): void &#123; console.log(\"The Accounting Department meets each Monday at 10am.\"); &#125; generateReports(): void &#123; console.log(\"Generating accounting reports...\"); &#125;&#125;let department: Department; // ok to create a reference to an abstract typedepartment = new Department(); // error: cannot create an instance of an abstract classdepartment = new AccountingDepartment(); // ok to create and assign a non-abstract subclassdepartment.printName();department.printMeeting();department.generateReports(); // error: method doesn't exist on declared abstract type","categories":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://dragonjun.github.io/categories/TypeScript/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://dragonjun.github.io/tags/TypeScript/"}]},{"title":"Typescript Interface","slug":"/TypeScript/2016-12-03-typescript-interface.html","date":"2016-12-02T20:00:00.000Z","updated":"2016-12-02T12:26:17.530Z","comments":true,"path":"/TypeScript/2016-12-03-typescript-interface.html","link":"","permalink":"http://dragonjun.github.io//TypeScript/2016-12-03-typescript-interface.html","excerpt":"","text":"TypeScript 핵심 원칙중 하나는 type를 검사할때 value가 가지고 있는 형태(shape)에 초점을 맞추는 것입니다. 이것을 “duck typing” 또는 “structural subtyping” 이라고 부릅니다. TypeScript에서 인터페이스는 이러한 type에 이름을 지어주는 역할을 하고 프로젝트 외부의 코드와의 계약 뿐만 아니라 코드 내부에서의 계약을 정의하는 강력한 방법이 됩니다. 첫번째 인터페이스123456function printLabel(labelledObj: &#123; label: string &#125;) &#123; console.log(labelledObj.label);&#125;let myObj = &#123;size: 10, label: \"Size 10 Object\"&#125;;printLabel(myObj); printLabel 호출에서 type을 검사합니다. printLabel 함수는 string type의 label property를 가지는 object를 한 개의 parameter로 받습니다. 실제로 object는 더 많은 property를 가지고 있지만 컴파일러는 필요한 최소한의 type만을 검사합니다. 이번에는 string type의 label property를 가지는 interface를 사용해서 예제를 다시 작성해 봅니다. 12345678910interface LabelledValue &#123; label: string;&#125;function printLabel(labelledObj: LabelledValue) &#123; console.log(labelledObj.label);&#125;let myObj = &#123;size: 10, label: \"Size 10 Object\"&#125;;printLabel(myObj); LabelledValue interface는 앞의 예제에서 요구 사항을 기술하는 데 사용합니다. 여전히 string type의 label이라는 단일 property을 갖는 것을 나타냅니다. printLabel에 전달한 object가 다른 언어에서와 같이 interface를 구현한다고 명시적으로 기술할 필요가 없었습니다. 여기서 중요한 것은 형태입니다. 함수에 전달 된 object가 나열된 요구 사항을 충족하면 허용됩니다. Optional Propertyinterface의 모든 property가 필요할 수는 없습니다. 특정 조건 하에서 존재하거나 전혀 존재하지 않을 수도 있습니다. 이러한 선택적 property는 두 개의 property 만 채워지는 함수에 object를 전달하는 “option bags”과 같은 패턴을 만들 때 널리 사용됩니다. 1234567891011121314151617interface SquareConfig &#123; color?: string; width?: number;&#125;function createSquare(config: SquareConfig): &#123;color: string; area: number&#125; &#123; let newSquare = &#123;color: \"white\", area: 100&#125;; if (config.color) &#123; newSquare.color = config.color; &#125; if (config.width) &#123; newSquare.area = config.width * config.width; &#125; return newSquare;&#125;let mySquare = createSquare(&#123;color: \"black\"&#125;); optional property는 이름의 마지막에 ?를 붙여서 선언합니다. Readonly propertyproperty를 readonly로 지정하면 object를 생성하고 후에 수정할 수 없습니다. 1234567interface Point &#123; readonly x: number; readonly y: number;&#125;let p1: Point = &#123; x:10, y:20 &#125;;p1.x = 5; // 에러 TypeScript에서는 Array&lt;T&gt;에서 수정하는 method를 없앤 ReadonlyArray&lt;T&gt;를 제공합니다. 1234567let a: number[] = [1, 2, 3, 4];let ro: ReadonlyArray&lt;number&gt; = a;ro[0] = 12; // 에러ro.push(5); // 에러ro.length = 100; // 에러a = ro; // 에러a = ro as number[]; // type assertion 사용하면 가능 readonly vs const변수는 const를 사용하고 property는 readonly를 사용합니다. Excess Property Check첫번째 예제에서 parameter로 { label: string; }를 받는 함수에 { size:number; label: string; }를 전달하는 것을 보았습니다. 또한 optional property과 이것이 “option bag”를 기술할때 유용하다는 것을 배웠습니다. 그러나 이 두가지를 단순하게 결합하면 어떻게 될까요? 마지막 예제를 다시 보겠습니다. 1234567891011121314151617interface SquareConfig &#123; color?: string; width?: number;&#125;function createSquare(config: SquareConfig): &#123;color: string; area: number&#125; &#123; let newSquare = &#123;color: \"white\", area: 100&#125;; if (config.color) &#123; newSquare.color = config.color; &#125; if (config.width) &#123; newSquare.area = config.width * config.width; &#125; return newSquare;&#125;let mySquare = createSquare(&#123;colour: \"red\", width:100&#125;); 여기서는 createSquare 함수에 color 대신 colour를 전달했습니다. 자바스크립트에서는 이런 것들은 조용히 버그를 유발합니다. 그러나 TypeScript에서는 코드에 버그가 있을 것이라는 입장을 보입니다. Object literal은 다른 변수에 할당되거나 인자로 전달될때 excess property checking를 거칩니다. object literal가 목표가 되는 type이 가지고 있지 않는 property를 가지고 있다면 에러가 발생합니다. 1let mySquare = createSquare(&#123;colour: \"red\", width:100&#125;); 이 검사는 피하는 방법은 세가지가 있습니다. type assertion index signature를 객체를 변수에 할당 가장 간단한 방법은 type assertion입니다. 1let mySquare = createSquare(&#123;colour: \"red\", width:100&#125; as SquareConfig); 그러나 객체가 특별한 방법으로 사용되는 몇 가지 추가 property을 가질 수 있다고 확신하는 경우 문자열 index signature를 추가하는 것이 더 나은 방법 일 수 있습니다. SquareConfigs가 위의 유형으로 색상 및 너비 property을 가질 수 있지만 다른 property도 여러 개 가질 수 있다면 다음과 같이 정의 할 수 있습니다. 12345interface SquareConfig &#123; color?: string; width?: number; [propName: string]: any;&#125; 이 검사를 피하는 마지막 방법은 객체를 다른 변수에 할당하는 것입니다. squareOptions가 excess property check를 거치지 않으므로 컴파일러에서 오류를 내지 않습니다. 12let squareOptions = &#123; colour: \"red\", width: 100 &#125;;let mySquare = createSquare(squareOptions); 위의 간단한 코드의 경우 이러한 검사를 피하려고 하면 안됩니다. 메소드와 상태를 유지하는 보다 복잡한 object literal의 경우 이러한 기법을 염두에 두어야 할 수도 있지만 대부분의 excess property error는 실제로 버그입니다. 즉 option bag과 같은 경우에 excess property checking 문제가 발생하는 경우 type 선언 중 일부를 수정해야 할 수도 있습니다. 이 경우 color 또는 colour 속성을 가진 객체를 createSquare에 전달하면 SquareConfig의 정의를 수정하여 이를 반영해야합니다. Function Type인터페이스는 JavaScript 객체가 취할 수있는 다양한 형태를 기술할 수 있습니다. 속성을 가진 객체를 기술하는 것 외에도 인터페이스는 함수 형태을 기술할 수 있습니다. 인터페이스가있는 함수 유형을 설명하기 위해 인터페이스에 call signature를 제공합니다. 이것은 주어진 매개 변수 목록과 반환 유형 만있는 함수 선언과 같습니다. 매개 변수 목록의 각 매개 변수에는 이름과 유형이 모두 필요합니다. 1234567891011121314interface SearchFunc &#123; (source: string, subString: string): boolean;&#125;let mySearch: SearchFunc;mySearch = function(source: string, subString: string) &#123; let result = source.search(subString); if (result == -1) &#123; return false; &#125; else &#123; return true; &#125;&#125; 파라미터의 이름이 일치할 필요하는 없습니다. 1234567891011121314interface SearchFunc &#123; (source: string, subString: string): boolean;&#125;let mySearch: SearchFunc;mySearch = function(src: string, sub: string) &#123; let result = src.search(sub); if (result == -1) &#123; return false; &#125; else &#123; return true; &#125;&#125; 기능 매개 변수는 한 번에 하나씩 검사되며 해당 매개 변수 위치의 유형이 서로 대조됩니다. type을 지정하지 않으면 function value가 SearchFunc type의 변수에 직접 할당되므로 Typescript는 문맥에서 argument type을 추론할 수 있습니다. 여기서도 함수 식의 반환 type은 반환하는 값 (여기에는 false 및 true)에 의해 암시됩니다. 함수식이 숫자 또는 문자열을 반환했다면 type checker는 반환 형식이 SearchFunc 인터페이스에 설명 된 반환 형식과 일치하지 않는다고 경고합니다. 1234567891011121314interface SearchFunc &#123; (source: string, subString: string): boolean;&#125;let mySearch: SearchFunc;mySearch = function(src, sub) &#123; let result = src.search(sub); if (result == -1) &#123; return false; &#125; else &#123; return true; &#125;&#125; Indexable Type함수 type을 설명하기 위해 인터페이스를 사용하는 방법과 마찬가지로 a[10] 또는 ageMap[ &quot;daniel&quot;]처럼 “색인을 생성”할 수있는 type을 설명 할 수 있습니다. 인덱싱 가능 type에는 indexing 할 때 대응하는 반환 유형과 함께 객체에 대해 indexing하는 데 사용할 수있는 유형을 설명하는 index signature가 있습니다. 예를 들어 보겠습니다. 12345678interface StringArray &#123; [index: number]: string;&#125;let myArray: StringArray;myArray = [\"Bob\", \"Fred\"];let myStr: string = myArray[0]; 위 예제에서 StringArray는 number로 indexing되며 string를 반환한다는 index signature를 기술하고 있습니다. index signature에는 string과 number의 두 종류가 있습니다. 두 종류를 같이 사용할 수 있지만 number index로 반환되는 type은 string index로 반환되는 type의 subtype이어야 합니다. 이는 자바스크립트에서는 number로 indexing를 하면 실제로 string로 바꿔서 indexing하기 때문입니다. number 100로 indexing하면 string &quot;100&quot;로 indexing 하는 것과 동일하므로 둘은 일관성이 있어야 합니다. 1234567891011class Animal &#123; name: string;&#125;class Dog extends Animal &#123; breed: string;&#125;interface NotOkay &#123; [x: number]: Animal; // 에러 [x: string]: Dog;&#125; string index signature은 “dictionary”패턴을 기술하는 강력한 방법이지만 모든 속성이 return type과 일치해야 합니다. 이것은 string index가 obj.property를 obj[ &quot;property&quot;]로 사용할 수 있다고 선언하기 때문입니다. 다음 예제에서 name의 type은 string index의 type과 일치하지 않으며 type-checker는 에러를 발생시킵니다. 12345interface NumberDictionary &#123; [index: string]: number; length: number; name: string; // 에러&#125; 마지막으로 index signature를 readonly로 만들 수 있습니다. 12345interface ReadonlyStringArray &#123; readonly [index: number]: string;&#125;let myArray: ReadonlyStringArray = [\"Alice\", \"Bob\"];myArray[2] = \"Mallory\"; // 에러 Class TypeImplementing interfaceC # 및 Java와 같은 언어로 인터페이스를 사용하는 가장 일반적인 방법 중 하나는 클래스가 특정 계약을 충족하도록 명시 적으로 적용하는 것이 TypeScript에서도 가능하다는 것입니다. 123456789101112interface ClockInterface &#123; currentTime: Date; setTime(d: Date): void;&#125;class Clock implements ClockInterface &#123; currentTime: Date; setTime(d: Date): void &#123; this.currentTime = d; &#125; constructor(h: number, m: number) &#123; &#125;&#125; Difference between the static and instance sides of classesclass에는 static side type과 instance side type이 있습니다.construct signature가 있는 인터페이스를 implement하는 class를 정의하면 에러가 발생합니다. 12345678interface ClockConstructor &#123; new (hour: number, minute: number): void;&#125;class Clock implements ClockConstructor &#123; currentTime: Date; constructor(h: number, m: number) &#123; &#125;&#125; 이것은 클래스가 인터페이스를 구현할 때 클래스의 instance side만 검사되기 때문입니다. 생성자는 static side에 있기 때문에이 체크에 포함되지 않습니다. 대신 클래스의 static side에서 직접 작업해야합니다. 이 예제에서는 constructor에 대한 ClockConstructor와 instance method에 대한 ClockInterface의 두 인터페이스를 정의합니다. 편의상 전달 type의 인스턴스를 생성하는 createClock constructor 함수를 정의합니다. 1234567891011121314151617181920212223242526interface ClockConstructor &#123; new (hour: number, minute: number): ClockInterface;&#125;interface ClockInterface &#123; tick(): void;&#125;function createClock(ctor: ClockConstructor, hour: number, minute: number): ClockInterface &#123; return new ctor(hour, minute);&#125;class DigitalClock implements ClockInterface &#123; constructor(h: number, m: number) &#123; &#125; tick() &#123; console.log(\"beep beep\"); &#125;&#125;class AnalogClock implements ClockInterface &#123; constructor(h: number, m: number) &#123; &#125; tick() &#123; console.log(\"tick tock\"); &#125;&#125;let digital = createClock(DigitalClock, 12, 17);let analog = createClock(AnalogClock, 7, 32); createClock(AnalogClock, 7, 32)에서 createClock의 첫 번째 매개 변수는 ClockConstructor type이므로 AnalogClock이 올바른 constructor signature을 갖고 있는지 확인합니다. Extending Interfaceclass와 같이 interface는 extend할 수 있습니다. 1234567891011interface Shape &#123; color: string;&#125;interface Square extends Shape &#123; sideLength: number;&#125;let square = &lt;Square&gt;&#123;&#125;;square.color = \"blue\";square.sideLength = 10; 여러개의 interface를 확장할 수 있습니다. 12345678910111213141516interface Shape &#123; color: string;&#125;interface PenStroke &#123; penWidth: number;&#125;interface Square extends Shape, PenStroke &#123; sideLength: number;&#125;let square = &lt;Square&gt;&#123;&#125;;square.color = \"blue\";square.sideLength = 10;square.penWidth = 5.0; Hybrid Type이전에 언급했듯이 인터페이스는 실제 JavaScript에서 제공되는 풍부한 type을 기술 할 수 있습니다. JavaScript의 역동적이고 유연한 특성으로 인해 위에 설명 된 일부 type의 조합으로 작동하는 객체가 종종 발생할 수 있습니다. 이러한 예는 추가 속성을 사용하여 함수와 object의 역할을 모두 수행하는 object입니다. 1234567891011121314151617interface Counter &#123; (start: number): string; interval: number; reset(): void;&#125;function getCounter(): Counter &#123; let counter = &lt;Counter&gt;function (start: number) &#123; &#125;; counter.interval = 123; counter.reset = function () &#123; &#125;; return counter;&#125;let c = getCounter();c(10);c.reset();c.interval = 5.0; 3rd-party JavaScript와 상호 작용할 때 type 형태를 완전히 기술하려면 위와 같은 패턴을 사용해야 할 수 있습니다.","categories":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://dragonjun.github.io/categories/TypeScript/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://dragonjun.github.io/tags/TypeScript/"}]},{"title":"Typescript 변수 선언","slug":"/TypeScript/2016-12-02-typescript-variable-declaration.html","date":"2016-12-01T20:00:00.000Z","updated":"2016-12-02T12:39:34.598Z","comments":true,"path":"/TypeScript/2016-12-02-typescript-variable-declaration.html","link":"","permalink":"http://dragonjun.github.io//TypeScript/2016-12-02-typescript-variable-declaration.html","excerpt":"","text":"let과 const는 자바스크립트에서 비교적 새로운 변수 선언 방법 입니다. let과 var는 비슷하지만 자바스크립트에서 흔한 “gotchas”https://en.wikipedia.org/wiki/Gotcha_(programming) 를 피할 수 있게 해 줍니다. const는 let에 변수에 재할당을 막도록 확장된 것입니다. TypeScript는 자바스크립트의 superset으로 let과 const를 지원합니다. 이 두가지 새로운 선언에 대해서 자세히 알아 보고 왜 var보다 더 바람직한지 설명할 것입니다. var 선언자바스크립트에서 변수를 선언은 var 키워드로 해왔습니다. 1var a = 10; 함수 안에서도 변수를 선언할 수 있습니다. 1234function f() &#123; var message = \"Hello, world!\"; return message;&#125; 그리고 다른 함수에서 이 변수들에 접근할 수 있습니다. 12345678910function f() &#123; var a = 10; return function g() &#123; var b = a + 1; return b; &#125;&#125;var g = f();console.log(g()); // 11을 출력 위 예에서 g는 f에서 선언된 변수 a를 캡처(capture)합니다. g가 호출될때 a의 값은 f안의 a의 값에 묶입니다. f가 실행을 완료했어도 g가 호출되면 a에 접근하고 수정할 수 있습니다. 123456789101112131415function f() &#123; var a = 1; a = 2; var b = g(); a = 3; return b; function g() &#123; return a; &#125;&#125;console.log(f()); // 2를 출력 Scoping rulesvar 선언은 이상한 scoping rules를 가집니다. 다음 예제를 보면: 12345678function f(shouldInitialize: boolean) &#123; if (shouldInitialize) &#123; var x = 10; &#125; return x;&#125;console.log(f(true)); // 10console.log(f(false)); // undefined 변수 x는 if 블럭(block)안에서 선언되었지만 블럭 밖에서도 접근할 수 있습니다. var 선언을 포함하는 블럭과는 관계 없이 그것을 감싸고 있는 함수, 모듈(module), 네임스페이스(namesapce) 또는 global scope의 어디에서나 접근이 가능합니다. 어떤 사람들은 이것을 var-scoping 또는 function-scoping라고 부릅니다. 파라미터(parameter)도 또한 function-scoping을 따릅니다. 이러한 scoping rule은 몇몇 형태의 실수를 유발할 수 있습니다. 그중 하나는 변수를 여러번 선언해도 에러가 아니라는 사실이다. 12345678910function sumMatrix(matrix: number[][]) &#123; var sum = 0; for (var i = 0; i &lt; matrix.length; i++) &#123; var currentRow = matrix[i]; for (var i = 0; i &lt; currentRow.length; i++) &#123; sum += currentRow[i]; &#125; &#125; return sum;&#125; 어쩌면 몇몇은 찾아내기 쉬울 수도 있습니다. i는 동일한 function-scope 변수이기 때문에 안쪽의 for-루프는 뜻하지 않게 변수 i를 덮어 씁니다.이런 버그는 코드리뷰에서도 잡기 어렵습니다. 변수 캡처의 이상한 점(variable capturing quirks)123for (var i = 0; i &lt; 10; i++) &#123; setTimeout(function() &#123; console.log(i); &#125;, 100 * i);&#125; setTimeout은 일정 시간 후에 함수를 실행합니다. 실행 결과는 이렇습니다. 1234567891010101010101010101010 많은 자바스크립트 개발자는 이 동작을 잘 알고 있지만, 대부분의 사람들은 출력이 다음과 같을 거라고 기대합니다. 123456789100123456789 setTimeout에 전달하는 모든 함수 표현식은 실제로 동일한 범위의 동일한 i를 참조합니다. setTimeout은 일정 시간 후에 함수를 실행하지만 for 루프가 실행을 중지 한 후에만 실행됩니다. for 루프가 실행을 멈출 때 i의 값은 10입니다. 따라서 주어진 함수가 호출될 때마다 10을 출력합니다. 일반적인 해결 방법은 즉시 호출 함수 표현인 IIFE(Immediately Invoked Function Expression)을 사용해서 각 반복에서 i를 캡처하는 것입니다. 1234567for (var i = 0; i &lt; 10; i++) &#123; // capture the current state of 'i' // by invoking a function with its current value (function(i) &#123; setTimeout(function() &#123; console.log(i); &#125;, 100 * 1); &#125;)(i);&#125; 이 특이한 패턴은 실제로 매우 일반적으로 사용됩니다. let 선언지금까지 var 키워드는 몇가지 문제가 있다는 것을 알게 되었고 그것이 let가 도입된 이유입니다. 1let hello = \"Hello!\"; Block-scopinglet을 사용해서 변수를 선언하면 lexical-scoping 또는 block-scoping을 사용합니다. 감싸고 있는 함수 전체로 scope를 넓히는 var로 선언된 변수와를 다르게 block-scope 변수는 가장 가까운 포함 블럭 또는 for루프 외부에서는 볼 수 없습니다. 123456789function f(input: boolean) &#123; let a = 100; if (input) &#123; let b = a + 1; return b; &#125; return b;&#125; a와 b는 로컬 변수입니다. a의 scope는 f의 바디로 제한되는데 비해 b의 scope는 if 문의 블럭으로 제한됩니다. catch절 안에서 선언된 변수도 비슷한 scoping 룰이 적용됩니다. 12345678try &#123; throw \"oh no!\";&#125;catch (e) &#123; console.log(\"Oh well.\");&#125;console.log(e); 블럭 범위 변수의 또 다른 특성은 실제로 선언되기 전에 읽거나 쓸 수 없다는 것입니다. 12a++;let a; 주의해야 할 점은 블럭 범위가 선언되기 전에 변수를 캡처할 수 있다는 것입니다. 단, 선언되기 전에 함수를 호출하는 것은 안됩니다. TypeScript에서는 에러가 발생하지는 않지만 ES2015에서는 실행할때 ReferenceError 예외가 발생합니다. 12345function foo() &#123; return a;&#125;foo();let a; Re-declarations and Shadowingvar 선언은 동일한 이름으로 여러번 선언해도 에러가 발생하지 않습니다. 1234567function f(x) &#123; var x; var x; if (true) &#123; var x; &#125;&#125; 위 예에서 모든 x 선언은 실제로 동일한 x를 참조합니다. 이것은 종종 버그의 원인이 됩니다.let은 다릅니다. 12let x = 10;let x = 20; // 에러: 동일한 scope에서는 다시 선언할 수 없습니다. 12345678function f(x) &#123; let x = 100; // 에러: 파라미터 선언과 간섭을 일으킵니다.&#125;function g() &#123; let x = 100; var x = 100; // 에러&#125; 블럭을 지정해 주면 동일한 이름으로 변수를 선언할 수 있습니다. 123456789function f(condition:boolean, x:number) &#123; if (condition) &#123; let x = 100; return x; &#125; return x;&#125;f(false, 0); // reutrn 0f(true, 0); // reutrn 100 안쪽 scope에 새로 선언하는 것을 shadowing라고 합니다. 어떤 버그는 막을 수 있지만 또 다른 버그를 만들어 낼 수 있습니다.예를 들어 sumMatrix 함수를 let으로 다시 작성했다고 생각해 봅시다. 12345678910function sumMatrix(matrix: number[][]) &#123; let sum = 0; for (let i = 0; i &lt; matrix.length; i++) &#123; var currentRow = matrix[i]; for (let i = 0; i &lt; currentRow.length; i++) &#123; sum += currentRow[i]; &#125; &#125; return sum;&#125; 이 버전은 안쪽 i가 바깥 루프의 i를 가려서 정확하게 합산을 수행할 수 있습니다. 더 명확한 코드를 작성하기 위해 shadowing은 일반적으로 피해야 합니다. Block-scoped variable capturingvar 선언으로 변수 캡처의 개념을 처음 접했을 때 일단 캡처 된 변수가 어떻게 작동하는지 간략하게 살펴 보았습니다. 이것에 대한 더 나은 직감을주기 위해 스코프가 실행될 때마다 변수의 “환경”을 생성합니다. 해당 환경 및 캡처 된 변수는 범위 내의 모든 항목이 완료된 후에도 존재할 수 있습니다. 1234567891011function theCityThatAlwaysSleeps() &#123; let getCity; if (true) &#123; let city = \"Seattle\"; getCity = function() &#123; return city; &#125; &#125; return getCity();&#125; 환경안에서 city를 캡처했으므로 if블럭이 실행을 완료했음에도 불구하고 여전히 액세스 할 수 있습니다. 이전의 setTimeout 예제에서는 for 루프를 반복 할 때마다 변수의 상태를 캡처하기 위해 IIFE를 사용해야한다는 결론을 얻었습니다. 사실 우리가 수행 한 작업은 캡처 된 변수에 대한 새로운 변수 환경을 만드는 것이 었습니다. 그것은 약간의 고통 이었지만, 다행스럽게도 TypeScript에서는 다시 할 필요가 없습니다. 루프의 일부로 선언될 때 let 선언은 철저하게 다른게 동작합니다.루프 자체에 새로운 환경을 도입하기보다는 반복마다 새로운 scope를 만듭니다.지금까지는 IIFE로 해왔으나 setTimeout 예제를 let 선언을 사용해서 바꿀 수 있습니다. 123for (let i = 0; i &lt; 10; i++) &#123; setTimeout(function() &#123; console.log(i); &#125;, 100 * i);&#125; 123456789100123456789 const 선언1const numLivesForCat = 9; let과 비슷하나 값을 바꿀 수 없습니다. 다시 말해서 동일한 scope 내에서 다시 할당 할 수 없습니다. 이것은 참조하는 값이 불변이라는 생각과 혼동되어서는 안됩니다. 12345678910111213141516const numLivesForCat = 9;const kitty = &#123; name: \"Aurora\", numLives: numLivesForCat&#125;// 에러kitty = &#123; name: \"Danielle\", numLives: numLivesForCat&#125;kitty.name = \"Rory\";kitty.name = \"Kitty\";kitty.name = \"Cat\";kitty.numLives--; 이를 피하기 위해 특별한 조치를 취하지 않으면 const 변수의 내부 상태가 여전히 수정 가능합니다. 다행히도 TypeScript를 사용하면 객체의 멤버를 읽기 전용으로 지정할 수 있습니다. 인터페이스 장에서 자세히 설명합니다.","categories":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://dragonjun.github.io/categories/TypeScript/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://dragonjun.github.io/tags/TypeScript/"}]},{"title":"TypeScript Type","slug":"/TypeScript/2016-12-01-typescript-type.html","date":"2016-11-30T20:00:00.000Z","updated":"2016-12-02T12:30:30.667Z","comments":true,"path":"/TypeScript/2016-12-01-typescript-type.html","link":"","permalink":"http://dragonjun.github.io//TypeScript/2016-12-01-typescript-type.html","excerpt":"","text":"TypeScript는 boolean, number, string, array, tuple, enum, any, void, null, undefined type을 제공합니다. booleanboolean type은 true와 false, 둘 중에 하나를 갖는 type입니다. 1let isDone: boolean = true; numbernumber type은 부동소수점 숫자를 갖는 type입니다.TypeScript에서 모든 숫자는 자바스크립트와 같이 부동소수점 숫자입니다. 12345let decimal: number = 6; // 10진수let hex: number = 0xf00d; // 16진수let binary: number = 0b1010; // 2진수let octal: number = 0o744; // 8진수let float: number = 3.141592; // 부동소수점 stringstring type은 0개 이상의 문자의 나열을 갖는 type입니다.string 리터럴(literal)은 큰 따옴표(“) 또는 작은 따옴표(‘)를 이용해서 표현합니다. 12let hello: string = \"world\";let animal: string = 'cat'; template string은 여러 라인에 걸칠 수 있고 식(expression)을 넣을 수 있습니다.template string은 backtick/backquote (`) 문자로 둘러 싸고 내장되는 식은 ${ expr }의 형태입니다. 12345let fullName: string = `Bob Bobbington`;let age: number = 37;let setence: string =`Hello, my name is $&#123; fullName &#125;.I'll be $&#123; age + 1 &#125; years old next month.` array배열은 두 가지 방법이 있습니다.첫번째는 요소의 type과 []를 사용하는 방법입니다. 1let list: number[] = [1, 2, 3]; 두번째는 generic array type, Array을 사용하는 방법입니다. 1let list: Array&lt;number&gt; = [1, 2, 3]; tupletuple는 요소(element)의 type을 지정하는 배열입니다. 123let x: [string, number] = [\"hello\", 1];x = [1, \"hello\"]; // 에러x[0] = 1; // 에러 type을 지정하지 않은 index 요소의 type은 union type이 됩니다. 12x[2] = \"world\"; // x[3]은 union type 'string | number'입니다.x[3] = true; // 에러, boolean은 string | number이 아닙니다. enumenum은 미리 정해진 상수(constant)의 집합인 type 입니다. 12enum Color &#123;Red, Green, Blue&#125;;let c: Color = Color.Green; enum은 숫자가 0부터 시작하지만 이것을 바꿀 수 있습니다. 12enum Color &#123;Red = 1, Green, Blue&#125;;let c: Color = Color.Green; 또는 모든 값을 정할 수 있습니다. 12enum Color &#123;Red = 1, Green = 2, Blue = 4&#125;;let c: Color = Color.Green; 값으로 부터 상수의 이름을 얻을 수 있습니다. 123enum Color &#123;Red = 1, Green, Blue&#125;;let colorName: string = Color[2];console.log(colorName); anytype을 알 수 없는 변수를 표현해야 할 떄가 있습니다. 이 경우 type checking를 하지 않고 compile-time check를 통과하고록 합니다. 그렇게 하기 위해서는 any type을 사용합니다. 123let notSure: any = 4;notSure = \"maybe a string instead\";notSure = false; voidvoid는 return 값이 없는 함수에서 사용합니다. 123function warnUser(): void &#123; alert(\"This is my warning message\");&#125; null과 undefinednull과 undefined은 각각 null type과 undefined type이 있습니다. 12let undefinedVariable: undefined = undefined;let nullVariable: null = null; 기본적으로 null과 undefined는 다른 type의 subtype입니다.이것은 null과 undefined를 number와 같은 type에 할당할 수 있다는 것을 의미합니다. 그러나 –strictNullChecks 플래그를 true로 설정하면 null과 undefined는 void과 각자 해당되는 type에만 할당할 수 있습니다. 이렇게 하면 많은 에러를 피할 수 있습니다. string 또는 null 또는 undefined를 넘기려면 union type string | null | undefined를 사용합니다. Type assertiontype assertion은 다른 언어에서 type cast와 비슷하나 data를 검사하거나 변환하지 않습니다.runtime에는 아무런 영향을 주지 않으며 compiler만 사용하니다. type assertion는 두 가지 형태가 있습니다. 하나는 angle-bracket 문법입니다. 12let someValue: any = \"this is a string\";let strLength: number = (&lt;string&gt;someValue).length; 다른 하나는 as 문법입니다. 12let someValue: any = \"this is a string\";let strLength: number = (soneValue as string).length; 둘중에 선호하는 것을 쓸 수 있으나 JSX와 사용할때는 as 문법이 허용됩니다.","categories":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://dragonjun.github.io/categories/TypeScript/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://dragonjun.github.io/tags/TypeScript/"}]}]}